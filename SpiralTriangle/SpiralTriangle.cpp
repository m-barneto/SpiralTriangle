#include <SFML/Graphics.hpp>
using namespace sf;

#include <iostream>
#include "delaunator.hpp"


std::vector<Vector2i> imageToPoints(const Image& img, const int& points) {
    const int width = img.getSize().x;
    const int height = img.getSize().y;


    // Vector to store points in
    std::vector<Vector2i> pointArray;
    pointArray.reserve(points);
    
    for (int i = 0; i < points; ++i) {
        // Random point inside image dimensions
        Vector2i randPoint = Vector2i(rand() % width, rand() % height);
        // While point is on a transparent pixel
        while (img.getPixel(randPoint.x, randPoint.y).a == 0) {
            // Assign point to new random point inside image dimensions
            randPoint = Vector2i(rand() % width, rand() % height);
        }
        pointArray.emplace_back(randPoint);
    }

    return pointArray;
}

const std::vector<double> getCoords(const std::vector<Vector2i>& particles) {
     //Vector for storing delaunator compliant positions
    std::vector<double> coords;
    coords.reserve(particles.size() * 2);

    // Unpacking Vector2 into it's two base components (x and y)
    for (int i = 0; i < particles.size(); i++) {
        coords.emplace_back(particles[i].x);
        coords.emplace_back(particles[i].y);
    }
    return coords;
}

inline float distSquared(const Vector2f& p1, const Vector2f& p2) {
    // Distance between two points without the square root (helps performance)
    // ((x2-x1)^2 + (y1-y2)^2)
    return ((p2.x - p1.x) * (p2.x - p1.x)) + ((p2.y - p1.y) * (p2.y - p1.y));
}

int main() {
    printf("Enter the image filepath: \n");
    std::string imagepath = "test_image.png";
    //std::getline(std::cin, imagepath);
    
    // Set random seed based on time
    time_t timeSeed = time(NULL);
    srand(timeSeed);
    printf("Seed: %d\n", (int)timeSeed);

    // Load image
    Image img;
    img.loadFromFile(imagepath);

    // Get points on image
    std::vector<Vector2i> points = imageToPoints(img, 200);

    // Convert points to format useable by delaunator
    std::vector<double> coords = getCoords(points);

    // Create delaunator
    delaunator::Delaunator d(coords);

    // Vector used to store the seed triangle lines
    std::vector<Vertex> vertices = std::vector<Vertex>();

    // Iterate over triangles generated by delaunator
    for (int i = 0; i < d.triangles.size(); i += 3) {
        // Organize points of each triangle into something easier to work with
        Vector2f points[3] = {
            Vector2f(d.coords[2 * d.triangles[i]], d.coords[2 * d.triangles[i] + 1]),
            Vector2f(d.coords[2 * d.triangles[i + 1]], d.coords[2 * d.triangles[i + 1] + 1]),
            Vector2f(d.coords[2 * d.triangles[i + 2]], d.coords[2 * d.triangles[i + 2] + 1])
        };

        // Distance between points allowed before hiding the line
        float distanceSquared = 150.f * 150.f;
        // Get distance of all lines
        float line1 = distSquared(points[0], points[1]);
        float line2 = distSquared(points[1], points[2]);
        float line3 = distSquared(points[2], points[0]);
        
        // Get the largest line
        float triangleLargestDist = fmaxf(line1, fmaxf(line2, line3));

        // If the largest line is over the max distance, skip the entire triangle
        // (If we only skipped the largest line, it would lead to open triangles)
        if (triangleLargestDist > distanceSquared) {
            continue;
        }

        // Line 1
        vertices.push_back(Vertex(points[0], img.getPixel(points[0].x, points[0].y)));
        vertices.push_back(Vertex(points[1], img.getPixel(points[1].x, points[1].y)));

        // Line 2
        vertices.push_back(Vertex(points[1], img.getPixel(points[1].x, points[1].y)));
        vertices.push_back(Vertex(points[2], img.getPixel(points[2].x, points[2].y)));

        // Line 3
        vertices.push_back(Vertex(points[2], img.getPixel(points[2].x, points[2].y)));
        vertices.push_back(Vertex(points[0], img.getPixel(points[0].x, points[0].y)));
    }


    // Create window with 8x antialiasing
    RenderWindow window(VideoMode::VideoMode(img.getSize().x, img.getSize().y), "Points", Style::Default, ContextSettings::ContextSettings(0U, 0U, 8U));
    

    while (window.isOpen()) {
        Event e;
        while (window.pollEvent(e)) {
            switch (e.type) {
            case Event::Closed:
                window.close();
                break;
            }
        }

        window.clear(Color::White);

        window.draw(&vertices[0], vertices.size(), PrimitiveType::Lines);

        window.display();
    }
}
