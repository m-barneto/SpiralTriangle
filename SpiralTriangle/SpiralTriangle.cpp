#include <SFML/Graphics.hpp>
using namespace sf;

#include <iostream>
#include "delaunator.hpp"


std::vector<Vector2i> imageToPoints(const Image& img, const int& points) {
    const int width = img.getSize().x;
    const int height = img.getSize().y;


    // Vector to store points in
    std::vector<Vector2i> pointArray;
    pointArray.reserve(points);
    
    for (int i = 0; i < points; ++i) {
        // Random point inside image dimensions
        Vector2i randPoint = Vector2i(rand() % width, rand() % height);
        // While point is on a transparent pixel
        while (img.getPixel(randPoint.x, randPoint.y).a == 0) {
            // Assign point to new random point inside image dimensions
            randPoint = Vector2i(rand() % width, rand() % height);
        }
        pointArray.emplace_back(randPoint);
    }

    return pointArray;
}

const std::vector<double> getCoords(const std::vector<Vector2i>& particles) {
     //Vector for storing delaunator compliant positions
    std::vector<double> coords;
    coords.reserve(particles.size() * 2);

    // Unpacking Vector2 into it's two base components (x and y)
    for (int i = 0; i < particles.size(); i++) {
        coords.emplace_back(particles[i].x);
        coords.emplace_back(particles[i].y);
    }
    return coords;
}

inline float distSquared(const Vector2f& p1, const Vector2f& p2) {
    // Distance between two points without the square root (helps performance)
    // ((x2-x1)^2 + (y1-y2)^2)
    return ((p2.x - p1.x) * (p2.x - p1.x)) + ((p2.y - p1.y) * (p2.y - p1.y));
}

inline Vector2f intersectingPoint(const Vector2f& pointA, const Vector2f& pointB, const Vector2f& pointC, const Vector2f& pointD) {
    float A1 = pointB.y - pointA.y;
    float B1 = pointA.x - pointB.x;
    float C1 = (A1 * pointA.x) + (B1 * pointA.x);
    float A2 = pointD.y - pointC.y;
    float B2 = pointC.x - pointD.x;
    float C2 = (A2 * pointC.x) + (B2 * pointC.y);

    float det = A1 * B1 - A2 * B1;

    float x = (B2 * C1 - B1 * C2) / det;
    float y = (A1 * C2 - A2 * C1) / det;
    return Vector2f(x, y);
}

int main() {
    printf("Enter the image filepath: \n");
    std::string imagepath = "test_image.png";
    //std::getline(std::cin, imagepath);
    
    // Set random seed based on time
    time_t timeSeed = time(NULL);
    srand(timeSeed);
    printf("Seed: %d\n", (int)timeSeed);

    // Load image
    Image img;
    img.loadFromFile(imagepath);

    // Get points on image
    //std::vector<Vector2i> imgPoints = imageToPoints(img, 200);
    std::vector<Vector2i> imgPoints = {
        Vector2i(200, 200),
        Vector2i(100, 350),
        Vector2i(300, 350)
    };

    // Convert points to format useable by delaunator
    std::vector<double> coords = getCoords(imgPoints);

    // Create delaunator
    delaunator::Delaunator d(coords);

    // Vector used to store the seed triangle lines
    std::vector<Vertex> vertices;

    // Iterate over triangles generated by delaunator
    for (int i = 0; i < d.triangles.size(); i += 3) {
        // Organize points of each triangle into something easier to work with
        Vector2f points[3] = {
            Vector2f(d.coords[2 * d.triangles[i]], d.coords[2 * d.triangles[i] + 1]),
            Vector2f(d.coords[2 * d.triangles[i + 1]], d.coords[2 * d.triangles[i + 1] + 1]),
            Vector2f(d.coords[2 * d.triangles[i + 2]], d.coords[2 * d.triangles[i + 2] + 1])
        };

        // Distance between points allowed before hiding the line
        float distanceSquared = 150.f * 150.f;

        // Get distance of all lines
        float line1 = distSquared(points[0], points[1]);
        float line2 = distSquared(points[1], points[2]);
        float line3 = distSquared(points[2], points[0]);

        // Get the largest line
        float triangleLargestDist = fmaxf(line1, fmaxf(line2, line3));

        // If the largest line is over the max distance, skip the entire triangle
        // (If we only skipped the largest line, it would lead to open triangles)
        if (triangleLargestDist > distanceSquared) {
            // TODO - Need to remove this when done testing spiral algorithm
            //continue;
        }

        // Line 1
        vertices.push_back(Vertex(points[0], img.getPixel(points[0].x, points[0].y)));
        vertices.push_back(Vertex(points[1], img.getPixel(points[1].x, points[1].y)));

        // Line 2
        vertices.push_back(Vertex(points[1], img.getPixel(points[1].x, points[1].y)));
        vertices.push_back(Vertex(points[2], img.getPixel(points[2].x, points[2].y)));

        // Line 3
        vertices.push_back(Vertex(points[2], img.getPixel(points[2].x, points[2].y)));
        vertices.push_back(Vertex(points[0], img.getPixel(points[0].x, points[0].y)));
    }

    CircleShape c(50.f);
    // go over each triangle and apply spiral algorithm
    for (int i = 0; i < d.triangles.size(); i += 3) {
        // Organize points of each triangle into something easier to work with
        Vector2f points[3] = {
            Vector2f(d.coords[2 * d.triangles[i]], d.coords[2 * d.triangles[i] + 1]),
            Vector2f(d.coords[2 * d.triangles[i + 1]], d.coords[2 * d.triangles[i + 1] + 1]),
            Vector2f(d.coords[2 * d.triangles[i + 2]], d.coords[2 * d.triangles[i + 2] + 1])
        };

        // Take first line
        // points[0] points[1]
        // Take second line
        // [points[1] points[2]
        Vector2f intersect = intersectingPoint(points[0], points[1], points[1], points[2]);
        c.setFillColor(Color::Red); 
        printf("X: %.2f, Y: %.2f\n", intersect.x, intersect.y);
        c.setPosition(intersect);
    }


    // Create window with 8x antialiasing
    RenderWindow window(VideoMode::VideoMode(img.getSize().x, img.getSize().y), "Points", Style::Default, ContextSettings::ContextSettings(0U, 0U, 8U));
    

    while (window.isOpen()) {
        Event e;
        while (window.pollEvent(e)) {
            switch (e.type) {
            case Event::Closed:
                window.close();
                break;
            }
        }

        window.clear(Color::White);

        window.draw(&vertices[0], vertices.size(), PrimitiveType::Lines);
        window.draw(c);
        window.display();
    }
}
